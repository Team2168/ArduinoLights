    //*****************************************************************************/
    //*****************************************************************************/
    // Title: Arduino LED Synchronization Breathing and Pulsation Code
    // Author: Brandon Spirito
    // Date Created: 2/18/2014
    // 
    //*****************************************************************************/
    // Revision: 1 
    // Date: 2/20/2014
    //
    //*****************************************************************************/
    //
    // Description: This code uses LPD8806-based RGB LED Modules in a strip with a main 
    // objective to provide the driver, shooter, and other team members/friendlies 
    // with visual cues to easily identify articulation movements and other various 
    // components on our 2168 competition robot.
    //
    //
    // 
    //*****************************************************************************/
    //*****************************************************************************/
    
    #include "LPD8806.h"
    #include "SPI.h"
    
    
    // Two LED strips with 8 LEDs per each strip located on the Intake Arm at the rear 
    // of the robot.
    //**These LED strips will be used to tell the driver when the Intake arm is down and 
    // ready to receive a ball.
    //**They will also be used to tell the driver when the intake arm is up.
    
    // Number of LEDs in a strand on both sides of intake arm.
    // Note* there will be two of these wired in parallel to give a ball feed look.
    int IntakeStripLength = 8;      // Number of LEDs * 2 along the rear on the intake arm  
                                    // will use two in parallel for 'feed me' effect.
                                    // [>> >> >> >>] && [<< << << <<]
    
    int DrivetrainRightLength = 16; // Number of LEDs along the right of the drivetrain
    int DrivetrainLeftLength  = 16; // Number of LEDs along the left of the drivetrain
    int ShooterRightLength    = 14; // Number of LEDs along the left of the shooter
    int ShooterLeftLength     = 14; // Number of LEDs along the right of the shooter
    int FrontLength           = 16; // Number of LEDs along the front 
    
    // General 
      // 1. Robot Enabled -- Ligtht up all LEDs GREEN 
      // 2. Robot Disabled -- Ligtht up all LEDs RED
      // 3. Intake Arm Up -- Solid Blue LED
      // 4. Intake Arm Down -- 'Feed me' two 8 LED strips in parallel
      // 5. Ball Setteled -- 
      // 6. Ball Ready to Shoot --
    // Tusk Position
      // 7. Tusk Truss Position
      // 8. Tusk High Position
      // 9. Tusk Ball Intake Low Position
    // Auto Mode:
      // 10. Left Target Hot -- Left side of Intake Arm Lite
      // 11. Right Target Hot -- Right side of Intake Arm Lite

    // Initialize colors
    int targetR = 0,
        targetG = 0,
        targetB = 0;
        
    int driveTargetR = 0,
        driveTargetG = 0,
        driveTargetB = 0;
        
    int R_OUT = 0,
        G_OUT = 0,
        B_OUT = 0;  
        
    // Choose output pins
    int dataPin1 = 11; // intake arm
    int dataPin2 = 10; // drivetrain right
    int dataPin3 =  9; // drivetrain left 
    int dataPin4 =  8; // shooter right
    int dataPin5 =  7; // shooter left
    int dataPin6 =  6; // Front 
    
    // Choose clock pin
    int clockPin = 3;  // shared clock
    
    // Bistable test cases
    boolean IntakeRaised       = false,
            IntakeLowered      = false,
            BallSettled        = false,
            BallReady          = false,
            TuskTrussPos       = false,
            TuskHighPos        = false,
            TuskBallIntakePos  = false,
            LeftTargetHot      = false,
            RightTargetHot     = false,
            Endgame            = false,
            AutonomousMode     = fal;
    
    
     //       CatapultTension = false,
     //       BallReady = false,
     //      BallLaunched = false,
     //      IntakeArmDown = false,
     //       IntakeArmUp = false,
     //       endgame = false,
     //       AutonomousMode = false;
    

    // First parameter is the number of LEDs in the strand.
    // Next two parameters are SPI data and clock pins.
    
    // Set strip "programming objects" which represent various LED strips.
    // This tells the 'strip' object that it is gong to be controlling the LEDs,
    // which are connected to 'dataPin' and 'clockPin'.
    
    // Each LED Strand denoted here:
    LPD8806 strip1 = LPD8806(IntakeStripLength,     dataPin1, clockPin);
    LPD8806 strip2 = LPD8806(DrivetrainRightLength, dataPin2, clockPin);
    LPD8806 strip3 = LPD8806(DrivetrainLeftLength,  dataPin3, clockPin);
    LPD8806 strip4 = LPD8806(ShooterRightLength,    dataPin4, clockPin);
    LPD8806 strip5 = LPD8806(ShooterLeftLength,     dataPin5, clockPin);
    LPD8806 strip6 = LPD8806(FrontLength,           dataPin6, clockPin);
    
    // LPD8806 strip = LPD8806(IntakeStripLength) for default pins 11 and 13    
    
    //*****************************************************************************/
    // Breathe Table - Brightness and Fading Time Cycle
    //*****************************************************************************/
    uint8_t LED_Breathe_Table[]  = 
    {  202, 211, 220, 228, 236, 242, 247, 251, 254, 255, 255, 254, 251, 247, 242, 236,
       228, 220, 211, 202, 192, 182, 172, 161, 151, 141, 131, 121, 112, 103,  95,  87,  
       80,  73,  66, 60,  55,  50,  45,  41,  38,  34,  31,  28,  26,  24,  22,  20,  
       20,  20,  20, 20,  20,  20,  20,  20,  20   };

    #define BREATHE_TABLE_SIZE (sizeof(LED_Breathe_Table))
    #define BREATHE_CYCLE    700   /*breathe cycle in milliseconds*/
    #define BREATHE_UPDATE    (BREATHE_CYCLE / BREATHE_TABLE_SIZE)
    
    //*****************************************************************************/
    
    void setup() {
    // Start up the LED strip
    strip1.begin();
    strip2.begin();

    int i, j;
    rainbowCycle(1); // Makes Rainbow cycle speed faster or slower.
  
    //*****************************************************************************/
    // BEGIN START-UP TEST    (check integrity using all colors - i.e. rainbow)
    //*****************************************************************************/
    // ---------Turn on LEDs---------
    
    // Rainbow Segment on Strip1 and Strip2 
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(i, Wheel( ((i * 384 / strip2.numPixels()) + j) % 384) ); 
    }
    strip2.show(); // perform show function on strip2. 
    delay(1000); // wait 1 s
    
    // Test White on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(256, 256, 256));  // White
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(127, 127, 127)); // White
    }
    strip2.show(); // perform show function on strip2.
    delay(200); wait 200 ms
   
    // Test Red on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127, 0, 0)); // Red
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(127, 0, 0)); // Red
    }
    strip2.show(); // perform show function on strip2. 
    delay(200); wait 200 ms
     
    // Test Yellow on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127, 127, 0)); // Yellow
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(127, 127, 0)); // Yellow
    }
    strip2.show(); // perform show function on strip2. 
    delay(200); wait 200 ms
    
    // Test Green on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(0, 127, 0)); // Green
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(0, 127, 0)); // Green
    }
    strip2.show(); // perform show function on strip2. 
    delay(200); wait 200 ms
    
    // Test Cyan on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(0, 127, 127)); // Cyan
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(0, 127, 127)); // Cyan
    }
    strip2.show(); // perform show function on strip2. 
    delay(200); wait 200 ms  
      
    // Test Blue on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(0, 0, 127)); // Blue
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(0, 0, 127)); // Blue
    }
    strip2.show(); // perform show function on strip2. 
    delay(200); wait 200 ms 
    
    // Test Violet on Strip1 and Strip2
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127, 0, 127)); // Violet
    }
    strip1.show(); // perform show function on strip1.
    for(int q = 0; q < strip2.numPixels(); q++) {
    strip2.setPixelColor(q, strip2.Color(127, 0, 127)); // Violet
    }
    strip2.show(); // perform show function on strip2. 
    delay(1000); wait 1 s
    
    // ---------Turn off LEDs---------
    
    for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip.Color(0,0,0));
    }
    strip1.show();
    for(int q = 0; q < strip2.numPixels(); q++) {
      strip2.setPixelColor(q, strip.Color(0,0,0));
    }
    strip2.show();
    
    //*****************************************************************************/
    // END OF START UP TEST
    //*****************************************************************************/
    
    // Set digital pins 3-10 as inputs
    pinMode(3, INPUT);
    pinMode(4, INPUT);
    pinMode(5, INPUT);
    pinMode(6, INPUT);
  
    Serial.begin(57600);
    } 
    
    //*****************************************************************************/
    // START OF MAIN LOOP
    //*****************************************************************************/
    
    void loop() {
      
    // COMMUNICATION PROTOCOL - BITMAP
    // BIT(S)     Meaning
    // ------------------------------
    //   0        Intake Arm 'raised' when true
    //   1        Intake Arm 'down'
    //   2        Ball 'Settled' 
    //   3        Ball 'Ready' to Shoot
    //   4        Tusk 'Truss' Position
    //   5        Tusk 'High' Position
    //   6        Tusk 'Ball Intake' Position
    //   7        Left Target Hot
    //   8        Right Target Hot
    //   9        Endgame (end of match notification)       
    
    lastInputValue = inputValue;
    inputValue = 0;
    
    //Read signals for cRIO
    if(digitalRead(3) == HIGH) {
      inputValue += 1; // inputvalue = inputvalue +1
    }
    if(digitalRead(4) == HIGH) {
      inputValue += 2;
    }
    if(digitalRead(5) == HIGH) {
      inputValue += 3;
    }
    if(digitalRead(6) == HIGH) {
      inputValue += 4;
    }
    if(digitalRead(7) == HIGH) {
      inputValue += 5;
    }
    if(digitalRead(8) == HIGH) {
      inputValue += 6;
    }
    if(digitalRead(9) == HIGH) {
      inputValue += 7;
    }
    if(digitalRead(10) == HIGH) {
      inputValue += 8;
    }
    if(digitalRead(11) == HIGH) {
      inputValue += 9;
    }
    if(digitalRead(12) == HIGH) {
      inputValue += 10;
    }
  
    if (inputValue != lastInputValue) {
    i = 0; //If new data, restart the loop

    // Check the status of the bits in from the message:
    IntakeRaised       = inputValue & 0x0001;
    IntakeLowered      = inputValue & 0x0002;
    BallSettled        = inputValue & 0x0003;
    BallReady          = inputValue & 0x0004;
    TuskTrussPos       = inputValue & 0x0005;
    TuskHighPos        = inputValue & 0x0006;
    TuskBallIntakePos  = inputValue & 0x0007;
    LeftTargetHot      = inputValue & 0x0008;
    RightTargetHot     = inputValue & 0x0009;
    Endgame            = inputValue & 0x0010;
    
    // Intake Raised or Lowered
    if(IntakeRaised) {
      //green
      targetR = 0;
      targetG = 127;
      targetB = 0;
    } else {
    //*****************************************************************************/
    // Intake Arm 'Feed Me' Loop
    //*****************************************************************************/
      int cycle1;
      // LED pulsation
      for (cycle1=0; cycle1 < 1; cycle1++) {
        uniformBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 2, 2, 200);
      }    
      // LED shifting 
      for (cycle1=0; cycle1 < 2; cycle1++) {    
        sequencedBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 200, 2, 20);
      }  
      }
  
    
    //*****************************************************************************/
    // DrivetrainRightLength
    //*****************************************************************************/  
    
    for(int q = 0; q < strip2.numPixels(); q++) {
      strip2.setPixelColor(q, strip2.Color(0,0,0));
    }
    strip2.show(); // perform show function on first strip only.
   
    int cycle2;
    
    // LED pulsation
    for (cycle2=0; cycle2 < 1; cycle2++) {
      uniformBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 200, 50, 100);
    }
      
    // LED shifting 
    for (cycle2=0; cycle2 < 2; cycle2++) {     // 200, 2, 20
      sequencedBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 16, 200, 200);
    }
    }  
     
    
    //*****************************************************************************/
    // END OF MAIN LOOP
    //*****************************************************************************/
    
    
    
    //*****************************************************************************/
    // Rainbow wheel - equal distribution along chain
    //*****************************************************************************/
    void rainbowCycle(uint8_t wait) {
      uint16_t i, j;
     
     for (j=0; j < 384 * 5; j++) {     // 5 cycles of all 384 colors in the wheel
       for (i=0; i < strip1.numPixels(); i++) {
        strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );
       }  
       for (i=0; i < strip1.numPixels(); i++) {
        strip2.setPixelColor(i, Wheel( ((i * 384 / strip2.numPixels()) + j) % 384) );
       }  
     strip1.show();   // write all the pixels out
     strip2.show();
     delay(wait);
     }
    } 
   
    //*****************************************************************************/
    // Pulsation and Sequencing 
    //*****************************************************************************/
    void uniformBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          breatheRed = (r * breatheTable[breatheIndex]) / 256;
          breatheGrn = (g * breatheTable[breatheIndex]) / 256;
          breatheBlu = (b * breatheTable[breatheIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
          
        for (i=0; i < strip2.numPixels(); i++) {
          breatheRed = (r * breatheTable[breatheIndex]) / 256;
          breatheGrn = (g * breatheTable[breatheIndex]) / 256;
          breatheBlu = (b * breatheTable[breatheIndex]) / 256;
          strip2.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show();
        strip2.show();   // write all the pixels out
        delay(updatePeriod);
      }
    }

    void sequencedBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
      uint8_t sequenceIndex;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          sequenceIndex = (breatheIndex + (i*4)) % breatheTableSize;
          breatheRed = (r * breatheTable[sequenceIndex]) / 256;
          breatheGrn = (g * breatheTable[sequenceIndex]) / 256;
          breatheBlu = (b * breatheTable[sequenceIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show(); 

        for (i=0; i < strip2.numPixels(); i++) {
          sequenceIndex = (breatheIndex + (i*4)) % breatheTableSize;
          breatheRed = (r * breatheTable[sequenceIndex]) / 256;
          breatheGrn = (g * breatheTable[sequenceIndex]) / 256;
          breatheBlu = (b * breatheTable[sequenceIndex]) / 256;
          strip2.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip2.show();
        
        delay(updatePeriod);
      }
    }
   
    //*****************************************************************************/
    // Helper Functions
    //*****************************************************************************/
    //Input a value 0 to 384 to get a color value.
    //The colours are a transition r - g -b - back to r
    uint32_t Wheel(uint16_t WheelPos) {
      byte r, g, b;
      switch(WheelPos / 128)
      {
        case 0:
          r = 127 - WheelPos % 128;   //Red down
          g = WheelPos % 128;      // Green up
          b = 0;                  //blue off
          break; 
        case 1:
          g = 127 - WheelPos % 128;  //green down
          b = WheelPos % 128;      //blue up
          r = 0;                  //red off
          break; 
        case 2:
          b = 127 - WheelPos % 128;  //blue down 
          r = WheelPos % 128;      //red up
          g = 0;                  //green off
          break; 
      }
      return(strip1.Color(r,g,b));
      return(strip2.Color(r,g,b));
    }
    //*****************************************************************************/
