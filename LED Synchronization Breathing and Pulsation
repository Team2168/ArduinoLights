    //*****************************************************************************/
    //*****************************************************************************/
    // Title: Arduino LED Synchronization Breathing and Pulsation Code
    // Author: Brandon Spirito
    // Date Created: 2/18/2014
    // 
    //*****************************************************************************/
    // Revision: 1 
    // Date: 2/20/2014
    //
    //*****************************************************************************/
    //
    // Description: This code uses LPD8806-based RGB LED Modules in a strip with a main 
    // objective to provide the driver, shooter, and other team members/friendlies 
    // with visual cues to easily identify articulation movements and other various 
    // components on our 2168 competition robot.
    //
    //
    // 
    //*****************************************************************************/
    //*****************************************************************************/
    
    #include "LPD8806.h"
    #include "SPI.h"
    
    
    // Two LED strips with 8 LEDs per each strip located on the Intake Arm at the rear 
    // of the robot.
    //**These LED strips will be used to tell the driver when the Intake arm is down and 
    // ready to receive a ball.
    //**They will also be used to tell the driver when the intake arm is up.
    
    // Number of LEDs in a strand on both sides of intake arm.
    // Note* there will be two of these wired in parallel to give a ball feed look.
    int IntakeStripLength = 8;      // Number of LEDs * 2 along the rear on the intake arm  
                                    // will use two in parallel for 'feed me' effect.
                                    // [>> >> >> >>] && [<< << << <<]
    int DrivetrainRightLength = 16; // Number of LEDs along the right of the drivetrain
    int DrivetrainLeftLength  = 16; // Number of LEDs along the left of the drivetrain
    int ShooterRightLength    = 14; // Number of LEDs along the left of the shooter
    int ShooterLeftLength     = 14; // Number of LEDs along the right of the shooter
    int FrontLength           = 16; // Number of LEDs along the front 
    
    // Initialize colors
    int targetR = 0,
        targetG = 0,
        targetB = 0;
        
    int driveTargetR = 0,
        driveTargetG = 0,
        driveTargetB = 0;
        
    int R_OUT = 0,
        G_OUT = 0,
        B_OUT = 0;  
        
    // Choose output pins
    int dataPin1 = 11; // intake arm
    int dataPin2 = 10; // drivetrain right
    int dataPin3 =  9; // drivetrain left 
    int dataPin4 =  8; // shooter right
    int dataPin5 =  7; // shooter left
    int dataPin6 =  6; // Front 
    
    // Choose clock pin
    int clockPin = 3;  // shared clock
    
    // Bistable test cases
    boolean CatapultTension = false,
            BallReady = false,
            BallLaunched = false,
            IntakeArmDown = false,
            IntakeArmUp = false,
            endgame = false,
            AutonomousMode = false;
    

    // First parameter is the number of LEDs in the strand.
    // Next two parameters are SPI data and clock pins.
    
    // Set strip "programming objects" which represent various LED strips.
    // This tells the 'strip' object that it is gong to be controlling the LEDs,
    // which are connected to 'dataPin' and 'clockPin'.
    LPD8806 strip1 = LPD8806(IntakeStripLength,     dataPin1, clockPin);
    LPD8806 strip2 = LPD8806(DrivetrainRightLength, dataPin2, clockPin);
    LPD8806 strip3 = LPD8806(DrivetrainLeftLength,  dataPin3, clockPin);
    LPD8806 strip4 = LPD8806(ShooterRightLength,    dataPin4, clockPin);
    LPD8806 strip5 = LPD8806(ShooterLeftLength,     dataPin5, clockPin);
    LPD8806 strip6 = LPD8806(FrontLength,           dataPin6, clockPin);
    
    // LPD8806 strip = LPD8806(IntakeStripLength) for default pins 11 and 13    
   
    //*****************************************************************************/
    // Breathe Table - Brightness and Fading Time Cycle
    //*****************************************************************************/
    uint8_t LED_Breathe_Table[]  = 
    {  202, 211, 220, 228, 236, 242, 247, 251, 254, 255, 255, 254, 251, 247, 242, 236,
       228, 220, 211, 202, 192, 182, 172, 161, 151, 141, 131, 121, 112, 103,  95,  87,  
       80,  73,  66, 60,  55,  50,  45,  41,  38,  34,  31,  28,  26,  24,  22,  20,  
       20,  20,  20, 20,  20,  20,  20,  20,  20   };

    #define BREATHE_TABLE_SIZE (sizeof(LED_Breathe_Table))
    #define BREATHE_CYCLE    700   /*breathe cycle in milliseconds*/
    #define BREATHE_UPDATE    (BREATHE_CYCLE / BREATHE_TABLE_SIZE)
    
    //*****************************************************************************/
    
    void setup() {
    // Start up the LED strip
    strip1.begin();
/*  strip2.begin();
    strip3.begin();
    strip4.begin();
    strip5.begin();
    strip6.begin();
*/      
    int i, j;
    
    rainbowCycle(1); // Makes Rainbow cycle speed faster or slower.
      
    //*****************************************************************************/
    // BEGIN START-UP TEST
    //*****************************************************************************/
    // Turn on Intake Arm LEDs (check integrity using all colors - i.e. rainbow)
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );
/*  strip2.setPixelColor(i, Wheel( ((i * 384 / strip2.numPixels()) + j) % 384) ); 
    strip3.setPixelColor(i, Wheel( ((i * 384 / strip3.numPixels()) + j) % 384) );
    strip4.setPixelColor(i, Wheel( ((i * 384 / strip4.numPixels()) + j) % 384) ); 
    strip5.setPixelColor(i, Wheel( ((i * 384 / strip5.numPixels()) + j) % 384) );
    strip6.setPixelColor(i, Wheel( ((i * 384 / strip6.numPixels()) + j) % 384) );  
*/
    }
     
    strip1.show(); // perform show function on first strip only.
/*  strip2.show();
    strip3.show();
    strip4.show();
    strip5.show();
    strip6.show();
*/  delay(200);
    
    // Test White  
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127, 127, 127)); // White
/*  strip2.setPixelColor(q, strip2.Color(127, 127, 127)); // White
    strip3.setPixelColor(q, strip3.Color(127, 127, 127)); // White
    strip4.setPixelColor(q, strip4.Color(127, 127, 127)); // White
    strip5.setPixelColor(q, strip5.Color(127, 127, 127)); // White
    strip6.setPixelColor(q, strip6.Color(127, 127, 127)); // White
*/  
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127,   0,   0)); // Red
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127, 127,   0)); // Yellow
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(  0, 127,   0)); // Green
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(  0, 127, 127)); // Cyan
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(  0,   0, 127)); // Blue
    }
    strip1.show(); // perform show function on first strip only.
    delay(200);
      
    for(int q = 0; q < strip1.numPixels(); q++) {
    strip1.setPixelColor(q, strip1.Color(127,   0, 127)); // Violet
    } 
    strip1.show(); // perform show function on first strip only.
    delay(200);
    
    //*****************************************************************************/
    // END OF START UP TEST
    //*****************************************************************************/
  
    //  Serial.begin(57600);
    } 
    
    //*****************************************************************************/
    // START OF MAIN LOOP
    //*****************************************************************************/
    
    void loop() {
      
    //*****************************************************************************/
    // Intake Arm 'Feed Me' Loop
    //*****************************************************************************/
    // Turn off Intake Arm LEDs (clearing the colors)
    
    for(int q = 0; q < strip1.numPixels(); q++) {
      strip1.setPixelColor(q, strip1.Color(0,0,0));
    }
    strip1.show(); // perform show function on first strip only.
  
    int cycle;
   
    // LED pulsation
    for (cycle=0; cycle < 1; cycle++) {
      uniformBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 2, 2, 200);
    }
      
    // LED shifting 
    for (cycle=0; cycle < 2; cycle++) {     // 200, 2, 20  //160,2,170
      sequencedBreathe(LED_Breathe_Table, BREATHE_TABLE_SIZE, BREATHE_UPDATE, 200, 2, 20);
      }  
    }
    //*****************************************************************************/
    // END OF MAIN LOOP
    //*****************************************************************************/
    
    
    
    //*****************************************************************************/
    // Rainbow wheel - equal distribution along chain
    //*****************************************************************************/
    void rainbowCycle(uint8_t wait) {
      uint16_t i, j;
     
     for (j=0; j < 384 * 5; j++) {     // 5 cycles of all 384 colors in the wheel
       for (i=0; i < strip1.numPixels(); i++) {
     // tricky math! we use each pixel as a fraction of the full 384-color wheel
     // (thats the i / strip.numPixels() part)
     // Then add in j which makes the colors go around per pixel
     // the % 384 is to make the wheel cycle around
        strip1.setPixelColor(i, Wheel( ((i * 384 / strip1.numPixels()) + j) % 384) );
       }  
     strip1.show();   // write all the pixels out
     delay(wait);
     }
    }
   
    //*****************************************************************************/
    // Pulsation and Sequencing 
    //*****************************************************************************/
    void uniformBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          breatheRed = (r * breatheTable[breatheIndex]) / 256;
          breatheGrn = (g * breatheTable[breatheIndex]) / 256;
          breatheBlu = (b * breatheTable[breatheIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show();   // write all the pixels out
        delay(updatePeriod);
      }
    }

    void sequencedBreathe(uint8_t* breatheTable, uint8_t breatheTableSize, uint16_t updatePeriod, uint16_t r, uint16_t g, uint16_t b)
    {
      int i;
      uint8_t breatheIndex = 0;
      uint8_t breatheRed;
      uint8_t breatheGrn;
      uint8_t breatheBlu;
      uint8_t sequenceIndex;
     
      for (breatheIndex = 0; breatheIndex < breatheTableSize; breatheIndex++) {
        for (i=0; i < strip1.numPixels(); i++) {
          sequenceIndex = (breatheIndex + (i*4)) % breatheTableSize;
          breatheRed = (r * breatheTable[sequenceIndex]) / 256;
          breatheGrn = (g * breatheTable[sequenceIndex]) / 256;
          breatheBlu = (b * breatheTable[sequenceIndex]) / 256;
          strip1.setPixelColor(i, breatheRed, breatheGrn, breatheBlu);
        }
        strip1.show();   // write all the pixels out
        delay(updatePeriod);
      }
    }
    
    //*****************************************************************************/
    // Helper Functions
    //*****************************************************************************/
    //Input a value 0 to 384 to get a color value.
    //The colours are a transition r - g -b - back to r
    uint32_t Wheel(uint16_t WheelPos)
    {
      byte r, g, b;
      switch(WheelPos / 128)
      {
        case 0:
          r = 127 - WheelPos % 128;   //Red down
          g = WheelPos % 128;      // Green up
          b = 0;                  //blue off
          break; 
        case 1:
          g = 127 - WheelPos % 128;  //green down
          b = WheelPos % 128;      //blue up
          r = 0;                  //red off
          break; 
        case 2:
          b = 127 - WheelPos % 128;  //blue down 
          r = WheelPos % 128;      //red up
          g = 0;                  //green off
          break; 
      }
      return(strip1.Color(r,g,b));
    }
    //*****************************************************************************/
